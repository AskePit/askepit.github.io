---
tags:
  - article
  - git
title: How in Earth do you write these retrospective articles of yours?
url-title: how_in_earth_do_you_write_these_retrospective_articles_of_yours
description: There s this type of article on blogs you read it and think how the hell was this written? The material is big, long, with lots of code, and the code evolves along the way, gets better. The author shows execution results, runs, benchmarks.
keywords:
  - git
  - articles
image: https://habrastorage.org/webt/nn/7h/oh/nn7hohvu_ajyl0tlmrwqy5orene.png
date: 28.09.2025
---

![](https://habrastorage.org/webt/nn/7h/oh/nn7hohvu_ajyl0tlmrwqy5orene.png)

There’s this type of article on blogs — you read it and think: how the hell was this written? The material is big, long, with lots of code, and the code evolves along the way, gets better. The author shows execution results, runs, benchmarks. The article even has a plot, its own kind of drama — at least as much as a technical article can have: bugs, dead ends, despair, flailing around, and sudden revelations.

More than once I’ve stared at one of those in awe, asking myself: _but how?.._. Because if you think about it — for the author to dump all those paleontological layers of their code on you, every version from the clumsy first steps to the grizzled, abstraction-laden final form — how exactly do they organize their work so that the article ends up in that shape?

Did they write the article in parallel with the code, recording everything that happened “live”? Some sort of programming with pencil and tape recorder? Or is it an honest retrospective: first you build what you wanted, and then, while the memories are still fresh, you dredge up the details? Or maybe a hybrid approach — milestone logged here, screenshot grabbed there, margin note scribbled somewhere else.

I never actually asked the authors of those articles how they pulled it off. Maybe I should have — it didn’t even cross my mind until I sat down to write this small piece. A piece about how I started facing the same problem myself, once I suddenly began writing retrospective articles on blogs.

# My experience

My [first](https://habr.com/ru/articles/794572/) big article in this genre — where you tell the story of success or failure after some time has passed — happened by accident. It was about a project we’d done a year earlier, writing a game, so it was a true retrospective. There wasn’t much code-driven storytelling in it, but even then I felt the burning need to dive into the past not only through memory but through the actual code. To remember exactly how something was bugging out, to grab a screenshot “from the past”, or to check what the code or the game looked like back then.

Obviously, where there’s a team and code, there’s version control. So of course I just hopped around old commits in git to fish out what I needed.

But it wasn’t always smooth sailing. The problems all boiled down to the same thing: commits made in real battlefield conditions of a real project aren’t always the best commits for a future retrospective. The typical issues:

- Commit names don’t always help you navigate history. You’re looking for the moment when the game still didn’t have a working main menu, but the commit log doesn’t let you pin down exactly where that was
- If a commit was too big, or worse — if it was a squash-commit from a large branch — it might turn out that the specific game state you’re after simply doesn’t exist in history, because it was “in between”
- Badly rewritten history (rebase, cherry-pick, reset) can distort the real chronology, making things harder to track down
- Dead-end experiments and failed variations of the program might never have made it into git at all

So yeah, with that article I hit some bumps, wasted a lot of unnecessary time, and realized that next time, if I knew or even suspected the code smelled like an article, I’d treat git with care — planting all the right markers, flags, and beacons in the repo.

And that’s exactly what happened, pretty soon, with the [Punk riff generator](https://habr.com/ru/articles/831852/) article. That was one of those cases where a dumb idea pops into your head and you immediately tell yourself: _this will be fun, and I’ll write an article about it too_. So it became a good testing ground for my blogo-gitology practices.

I kept a [GitHub repo](https://github.com/AskePit/punk-riff-generator) and carefully logged everything. The rule was literally just one: treat commits responsibly. Each commit should be atomic, a complete piece of work; small or tiny in size; well-named. Well, programmers already know that’s how it should be anyway.

Here’s what the project history looked like by the end:

![git-history of project Punk riff generator](https://habrastorage.org/webt/ia/pd/p4/iapdp481fnizaeh4-9ltadvsdj4.png)

Later it really was easy to write the article with such a cheat sheet in hand. I won’t say that the article itself came easily — but at least I had zero problems with retrospective code rollbacks.

Notice the abundance of tags — they were super handy for marking important stages and milestones. For example, tags can play the role of what eventually becomes _chapters_ in your article.

Another, more recent example — the [epic article](https://habr.com/ru/articles/950046/) (49 minutes of reading!) about coin flipping. The code evolved in multiple directions, with frequent digressions, shifting goals along the way, dead-end solutions, and bugs. Everything had to be thoroughly logged so I could write the article in a sane and comfortable manner.

The history of the [repository](https://github.com/AskePit/coin-flip-brutal) by the time the work was done looked kind of terrifying at first glance:

![git-history of project Coin flip brutal](https://habrastorage.org/webt/nj/im/ru/njimrufubyfl23eaqdvxj9pyfvc.png)

Yeah, it looks messy. But if the author can navigate their own system, it’s no problem to use this cheat sheet effectively. The biggest payoff I got from a well-structured project history was when I needed to run benchmarks retroactively on a whole bunch of program versions. Without a solid git history, I’d probably have just given up.

# Good git

Tips for keeping a repo in fighting shape for a potential article:

- Well-crafted commits are the foundation. Before committing, think about how informative, useful, and transparent it will be for _future you_, digging through history in search of the right information
    
- Tags can help mark key points or add any meta-information you might need
    
- If you’ve got a dead-end scenario but want to preserve it in history, or say you stumbled upon a particularly juicy bug — make a branch. That way the code sits isolated from the main narrative flow. Plus, you get a tag automatically
    

# Bad git

I’ve painted a rosy picture, but there’s a big problem. It shows up when you want to rewrite history. And you _will_ want to rewrite history. The reasons are plenty:

- Ten commits later you realize you could have written something clearer and more illustrative
    
- You suddenly see how idiotic the name of a function you wrote at the very start is, and now the whole history is littered with it
    
- You want to shuffle the chronology of events a little
    

And all of that is technically possible! Tools like `git rebase -i`, `git cherry-pick`, and `git filter-branch` will happily help. The catch is that when you rewrite history, tags and branches stay stuck to their old spots. That bug branch sprouted from commit `aaaa` will still be based on `aaaa`, even if your _real_ `aaaa` has long since turned into `bbbb` after a rebase. And if at some point you’ve rewritten the history from head to toe, all your branches (and tags) have to be stitched back manually through painful `git reset --hard` and `git reflog` gymnastics. The process is so tedious that I wouldn’t recommend it to anyone.

Which brings me to the only possible conclusion: git is probably not the best tool, not the best version control system for this kind of task — where rewriting commit history is basically a standard workflow. The problem is, I’m not deeply familiar with alternative VCSs. I’d be glad if someone could suggest something worthwhile.

Or maybe you write your retrospective articles in a completely different way? Maybe there’s a much simpler path. I’d be glad here too if someone could share their experience.

# Bonus cheat sheet

<details>
  <summary>Cheat sheet for highly specific git commands</summary>
  
- Rename function `doWork` to `spin` across the *entire* history:

```bash
git filter-branch --tree-filter 'find . -type f -name "*.cpp" | xargs sed -i "s/doWork/spin/g"' -- --all
```

- Same thing, but only for a commit range:

```bash
git filter-branch --tree-filter 'find . -type f -name "*.cpp" | xargs sed -i "s/doWork/spin/g"' -- --all deadbe..abcdef
```

- Delete all local tags:

```bash
git tag -d $(git tag -l)
```

- Delete all remote tags:

```bash
git ls-remote --tags origin | awk '{print $2}' | sed 's#refs/tags/##' | while read -r tag; do
  git push origin --delete "$tag"
done
```

- Swap commits `aaa1` and `aaa2`:

  - Run `git rebase -i aaaa1~`
  - In the commit list, swap the lines for `aaa1` and `aaa2`
  - Resolve conflicts

- Split an old commit into several:

  - Run `git rebase -i aaaa~`
  - In the commit list, mark commit `aaaa` as `e` (edit) and continue
  - `git reset HEAD~`
  - Then create as many new commits from the unstaged changes as you like

- From a bunch of changes in one file, stage only the ones you want:

```bash
# launches interactive staging mode
git add -p
```
</details>

---
<small>© Nikolai Shalakin. Translated by the author.</small>
