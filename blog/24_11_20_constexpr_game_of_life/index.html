
<!DOCTYPE html>
<html>
<head lang="en">
    <title>constexpr Game of Life</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="For over a decade now, C++ has had constexpr, a feature that allows programmers to dump part of the workload onto the compiler. When I first encountered it, it blew my mind—imagine the compiler crunching some pretty complex calculations before the program even runs!">
    <meta name="keywords" content="c++, constexpr, python, game of life, abnormal programming">
    <meta name="author" content="Nikolai Shalakin">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://askepit.github.io/blog/constexpr_game_of_life/">
    <!-- Open Graph -->
    <meta property="og:title" content="constexpr Game of Life">
    <meta property="og:description" content="For over a decade now, C++ has had constexpr, a feature that allows programmers to dump part of the workload onto the compiler. When I first encountered it, it blew my mind—imagine the compiler crunching some pretty complex calculations before the program even runs!">
    <meta property="og:image" content="https://habrastorage.org/webt/p1/t-/7c/p1t-7csilx5ekan-m7ryligjg3o.png">
    <meta property="og:url" content="https://askepit.github.io/blog/constexpr_game_of_life/">
    <meta property="og:type" content="article">
    <!-- Twitter Cards -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="constexpr Game of Life">
    <meta name="twitter:description" content="For over a decade now, C++ has had constexpr, a feature that allows programmers to dump part of the workload onto the compiler. When I first encountered it, it blew my mind—imagine the compiler crunching some pretty complex calculations before the program even runs!">
    <meta name="twitter:image" content="https://habrastorage.org/webt/p1/t-/7c/p1t-7csilx5ekan-m7ryligjg3o.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,200..900;1,200..900&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap');
    </style>
    <link rel="stylesheet" href="../styles_common.css" id="common-styles" type="text/css"/>
    <link rel="stylesheet" href="../typography_neutral.css" id="typography" type="text/css"/>
    <link rel="stylesheet" href="../styles_dark.css" id="theme" title="Light" type="text/css"/>
    <link rel="stylesheet" href="../switches.css" id="switcher-styles" type="text/css"/>
    <link rel="stylesheet" href="../hamburger_menu.css" id="switcher-styles" type="text/css"/>
</head>
<body>
<script>
MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<input id="hamburger-switch" class="hamburger-checkbox" type="checkbox" name="hamburger">
<label for="hamburger-switch" class="hamburger-menu">
    <div class="hamburger">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-menu">
            <line x1="4" y1="12" x2="20" y2="12"></line>
            <line x1="4" y1="6" x2="20" y2="6"></line>
            <line x1="4" y1="18" x2="20" y2="18"></line>
        </svg>
    </div>
    <input id="theme-switch" class="switch-checkbox" type="checkbox" name="theme">
    <label for="theme-switch" class="switch-body">
        <div class="checked-state moon"></div>
        <div class="unchecked-state sun"></div>
        <div class="slider"></div>
    </label>
    <input id="typography-switch" class="switch-checkbox" type="checkbox" name="typo" style="top: 190px;">
    <label for="typography-switch" class="switch-body second">
        <div class="checked-state serif"></div>
        <div class="unchecked-state sans"></div>
        <div class="slider"></div>
    </label>
</label>
<h1>constexpr Game of Life</h1>
<h2>How It All Began</h2>
<p>For over a decade now, C++ has had <a href="https://en.cppreference.com/w/cpp/language/constexpr"><code>constexpr</code></a>, a feature that allows programmers to dump part of the workload onto the compiler. When I first encountered it, it blew my mind—imagine the compiler crunching some pretty complex calculations <i>before the program even runs</i>!</p>
<p>At some point, a thought struck me: if the compiler can calculate everything for you, then <b>why bother with runtime at all</b>? What are you going to do there—print out some results? Come on, that's lame. Totally unsportsmanlike.</p>
<p>And that's exactly when my challenge was born:</p>
<blockquote><p>"Hands off" or "don’t even think about running the exe file."</p></blockquote>
<h2>Setting the Goal</h2>
<p>Let’s spell out the main idea one more time for clarity: we want to write a program, compile it, and have <b>all</b> computations happen <i>during compilation</i>. Actually running the program? <i>Not interested.</i></p>
<p>But the code <b>must work</b>.</p>
<p>Contradictory? Perhaps. Impossible? Nah. We’re doing this.</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/p1/t-/7c/p1t-7csilx5ekan-m7ryligjg3o.png" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>Complicating Factors: I'm a Windows Dev. Ah yes, I’m one of those <i>Windows programmers</i>. Go ahead, prepare your popcorn for the inevitable flame wars. For me, this means dealing with Windows-specific horrors: Visual Studio's compiler, <code>cmd</code>, <code>bat</code>, <code>exe</code>, and all the other nightmares that haunt Linus's dreams. This setup will undoubtedly throw extra wrenches into the works, but hey, I’m all for it.</p>
<p>The program must do something reasonable and useful. The overplayed examples of calculating factorials or Fibonacci numbers are off the table—too cliché, zero practical value, and utterly unchallenging. Forcing the compiler to play Doom? Tempting, but I’ll pass. Not because the compiler couldn't handle it, but because <i>I</i> probably couldn’t handle it.</p>
<p>So, I landed somewhere in the middle. We’ll make the compiler play a game, but something significantly simpler. Say, <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game of Life</a>. I mean, if even Google <a href="https://www.google.com/search?q=game+of+life&oq=game+of+life">can run this simulation directly on their search page</a>, why can’t I force a C++ compiler to do the same?</p>
<p>For those who didn’t click the links and aren’t familiar with this “game,” here’s an animation:</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/qy/aa/qd/qyaaqd5gqbax2fjijv1clg2bbkk.gif" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>Let’s refresh the rules of the Game of Life:</p>
<ul>
	<li>If a cell is alive and has fewer than two neighbors, it dies.</li>
	<li>If a cell is alive and has more than three neighbors, it dies.</li>
	<li>If a cell is empty but has exactly three neighbors, life is born in that cell.</li>
	<li>And so it goes, generation after generation, endlessly.</li>
</ul>
<p>“But wait,” you’ll say, “Game of Life is a <i>game</i>. It needs frames, a main loop, infinite execution, rendering—even animations! And here you are spinning us some nonsense about compile-only.”</p>
<p>Fair point. But in this challenge, I’m giving myself plenty of room for creativity. The one hard rule is this: <b>you cannot execute the compiled file.</b> Not directly, not indirectly. Beyond that? Anything goes. And this is where we’ll need to get <i>very</i> creative.</p>
<h2>Nuances of <code>constexpr</code></h2>
<p>Let’s clarify some language subtleties upfront. In C++, you can mark a function or method as <code>constexpr</code>. But—and here’s the kicker—this doesn’t guarantee compile-time execution. If the function is called with non-<code>constexpr</code> parameters, your <code>constexpr</code> marker will be quietly ignored, and you won’t even get a heads-up about it.</p>
<p>For example, take this code—it <i>will</i> perform the calculation during compilation:</p>
<pre><code class="language-cpp"><span class="code-keyword">constexpr int</span> <span class="code-call">twice</span>(<span class="code-keyword">int</span> n)
{
    <span class="code-keyword">return</span> n * <span class="code-literal">2</span>;
}

<span class="code-keyword">int</span> <span class="code-call">main</span>()
{
    <span class="code-keyword">return</span> <span class="code-call">twice</span>(<span class="code-literal">17</span>);
}</code></pre>
<p>The program will exit with code <code>34</code>, and the calculation <code>17 * 2</code> will have been performed during compilation, meaning the binary will simply store the result <code>34</code>.</p>
<blockquote><p>Of course, we’re talking theory here, so let’s skip over the fact that the compiler can optimize such trivial multiplication all on its own, even without explicitly using <code>constexpr</code>. For the sake of this discussion, let’s pretend the compiler won’t bother without it.</p></blockquote>
<p>Now, let’s tweak things to make compile-time execution <i>impossible</i>:</p>
<pre><code class="language-cpp"><span class="code-keyword">constexpr int</span> <span class="code-call">twice</span>(<span class="code-keyword">int</span> n)
{
    <span class="code-keyword">return</span> n * <span class="code-literal">2</span>;
}

<span class="code-keyword">int</span> <span class="code-call">main</span>()
{
    <span class="code-keyword">int</span> n;
    std::cin &gt;&gt; n;
    <span class="code-keyword">return</span> <span class="code-call">twice</span>(n);
}</code></pre>
<p>Now, the return code depends on user input, which means the compiler's ability to compute the result at compile-time is effectively <i>gone</i>. However, the code still compiles and runs. This demonstrates that the <code>twice</code> function can be legally used in both compile-time and runtime contexts.</p>
<p>That said, it doesn’t mean you can just slap <code>constexpr</code> onto any function as a catch-all. The moment you add something incompatible with compile-time evaluation, you’ll be greeted with a compilation error:</p>
<pre><code class="language-cpp"><span class="code-keyword">constexpr int</span> <span class="code-call">twice</span>(<span class="code-keyword">int</span> n)
{
    std::cout &lt;&lt; n * <span class="code-literal">2</span> &lt;&lt; std::endl;
    <span class="code-keyword">return</span> n * <span class="code-literal">2</span>;
}</code></pre>
<p>When we try to compile this, we get:</p>
<pre><code class="language-"><span class="code-keyword">error</span> C3615: <span class="code-keyword">constexpr</span> <span class="code-keyword">function</span> <span class="code-literal">'twice'</span> cannot result <span class="code-keyword">in</span> a constant expression</code></pre>
<p>Okay, but what if I want to guarantee that my function always, <i>always</i> runs in a compile-time context? Enter <a href="https://en.cppreference.com/w/cpp/types/is_constant_evaluated"><code>std::is_constant_evaluated</code></a> from C++20. This is a <code>constexpr</code> function you can call inside another <code>constexpr</code> function to check if you’re <i>actually</i> in a <code>constexpr</code> context or if you’ve been downgraded to runtime. Because, of course, the C++ standards committee loves its complexities.</p>
<p>In our case, we <i>need</i> to ensure we’re operating in a compile-time context. Any deviation from this course should ideally result in a compilation error. Sure, we could wrap ourselves in layers of <code>constexpr</code> and sprinkle some <code>std::is_constant_evaluated</code> checks. But, fortunately, the same C++20 also introduced the <a href="https://en.cppreference.com/w/cpp/language/consteval"><code>consteval</code></a> specifier. Think of it as <code>constexpr</code> on steroids: it marks a method as being <i>exclusively</i> for compile-time execution. Any attempt to use it at runtime will immediately throw a righteous compilation error. And that’s exactly what we need—strict guarantees that the compiler’s exe will sweat, not ours.</p>
<blockquote><p>This article uses C++20 features and, when necessary, dips into C++23. Not everyone can unleash these wonders in production, but hey, that’s just life as a C++ developer.</p></blockquote>
<h2>Starting the Game of Life</h2>
<p>Let’s begin by writing some code without worrying about <code>consteval</code> or other quirks for now. We’ll sort that out as we go.</p>
<p>So, we need a canvas of a specific size. I’m going with 16x16. Later, you’ll see why I chose this size and (hopefully) admire the cleverness.</p>
<p>And so, the abnormal programming begins:</p>
<pre><code class="language-cpp">#<span class="code-keyword">include</span> &lt;array&gt;

<span class="code-keyword">constexpr</span> <span class="code-keyword">bool</span> _ = <span class="code-keyword">false</span>;
<span class="code-keyword">constexpr</span> <span class="code-keyword">bool</span> X = <span class="code-keyword">true</span>;

<span class="code-keyword">constexpr</span> size_t N = <span class="code-literal">16</span>;
<span class="code-keyword">using</span> Canvas = std::array&lt;std::array&lt;<span class="code-keyword">bool</span>, N&gt;, N&gt;;

<span class="code-keyword">constexpr</span> Canvas life { {
	{_,X,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,X,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
	{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,},
} };

<span class="code-keyword">int</span> <span class="code-call">main</span>()
{
    <span class="code-keyword">return</span> life[<span class="code-literal">0</span>][<span class="code-literal">1</span>];
}</code></pre>
<p>I know, I said I wouldn’t bother with compile-time stuff for now, and then I went ahead and smothered everything in <code>constexpr</code>. Well, forgive me—I couldn’t resist. There’s no real computation yet, but I’ve already laid the groundwork.</p>
<p>Here’s what we’ve done so far: we introduced a two-dimensional canvas entity, <code>Canvas</code>, and declared the starting frame of the game, <code>life</code>, which contains a curious little pattern called the <i>Glider</i>. In the Game of Life, the Glider behaves like a rotating, moving object that more or less retains its shape over a defined period. Easier to show than to explain:</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/f1/je/pf/f1jepfxskshjwvskqqsofflp9kg.gif" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>This pattern is perfect for testing the game logic—it should move diagonally downward and to the right every frame.</p>
<p>Now, I foresee a question: "why did you add <code>return life[0][1];</code>?" Without that line, the compiler would decide all our variables were pointless fluff and cut <i>everything</i> from the binary.</p>
<p>Also, the <code>[0][1]</code> position contains a live cell, so the program should return <code>1</code> when it exits. Not that it ever <i>will</i> exit, mind you—remember the main rule of this challenge!</p>
<p>Of course, we’re not at the stage of executing anything yet, since we haven’t even compiled anything.</p>
<hr>
<h2>Running the Compiler</h2>
<p>Since we’re on Windows, the most logical compiler at our disposal is the one used by Visual Studio—Microsoft Visual C++ (MSVC). Its binary is famously named <code>cl.exe</code>.</p>
<p>Now, we <i>don’t</i> want to use Visual Studio as an IDE—that’s for the faint of heart. Our goal is to use <code>cl.exe</code> directly. And here we hit our first snag. On Linux, you can simply open a terminal and immediately run <code>gcc</code> to get down to business. But if you open a fresh <code>cmd</code> and type <code>cl /help</code>, you’ll get:</p>
<pre><code class="language-"><span class="code-literal">'cl'</span> <span class="code-keyword">is</span> <span class="code-keyword">not</span> recognized <span class="code-keyword">as</span> an internal <span class="code-keyword">or</span> external command,
operable program <span class="code-keyword">or</span> batch file.</code></pre>
<p>By default, the shell environment isn’t configured to work with <code>cl</code> out of the box, and the path to it isn’t even included in <code>PATH</code>. And yes, this is <i>by design</i>. Here’s <a href="https://learn.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170">some delightfully verbose documentation</a> about how to simply get <code>cl</code> up and running.</p>
<p><b>TL;DR</b>: To handle the Visual C++ compiler manually, you first need to set up the shell environment. There are nearly a dozen ways to do this, depending on your desired platform and bitness. For each configuration, there’s a dedicated <code>.bat</code> file. Rule #1 of Windows compiler hygiene: first run the environment setup batch file, then use <code>cl</code>.</p>
<p>Here’s how it works:</p>
<pre><code class="language-bash"><span class="code-literal">"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"</span>

cl /help</code></pre>
<p>Here, we used the batch file for x64-native tools, which suits our needs.</p>
<p>You know all those x64/x86 Native Tools Command Prompt for VS2022 shortcuts? They’re essentially pre-configured shells where you can run <code>cl.exe</code> straight out of the box. But we’re dismissing that option too, because we want to compile from any bare terminal.</p>
<p>At this stage, the command we need for compilation looks like this:</p>
<pre><code class="language-bash">cl /std:c++latest main.cpp</code></pre>
<p>Its execution confirms that our setup compiles successfully, so we can proceed with writing more code.</p>
<h2>Stretching the Compile-Time Boundaries</h2>
<p>With the compiler primed and ready, let’s soldier on with our Game of Life implementation.</p>
<p>In reality, the computational part of our simulation is painfully simple: you take an old <code>Canvas</code>, calculate the new <code>Canvas</code> based on the game’s rules, render/display it somehow, and repeat this until the end of time—that’s the whole program. The cornerstone of this algorithm is a function with the signature <code>Canvas update(Canvas old)</code>, responsible for calculating the next generation of cells:</p>
<pre><code class="language-cpp"><span class="code-keyword">consteval</span> Canvas <span class="code-call">update</span>(Canvas old)
{
    Canvas res;

    <span class="code-keyword">for</span> (<span class="code-keyword">int</span> r = <span class="code-literal">0</span>; r &lt; N; ++r) {
        <span class="code-keyword">for</span> (<span class="code-keyword">int</span> c = <span class="code-literal">0</span>; c &lt; N; ++c) {

            <span class="code-keyword">int</span> neighboursCount = <span class="code-literal">0</span>;
            <span class="code-keyword">for</span> (<span class="code-keyword">int</span> nr = r - <span class="code-literal">1</span>; nr &lt;= r + <span class="code-literal">1</span>; ++nr) {
                <span class="code-keyword">for</span> (<span class="code-keyword">int</span> nc = c - <span class="code-literal">1</span>; nc &lt;= c + <span class="code-literal">1</span>; ++nc) {
                    <span class="code-keyword">if</span> (nr == r && nc == c) <span class="code-keyword">continue</span>;

                    <span class="code-keyword">int</span> wrappedR = (nr + N) % N;
                    <span class="code-keyword">int</span> wrappedC = (nc + N) % N;
                    neighboursCount += <span class="code-keyword">static_cast</span>&lt;<span class="code-keyword">int</span>&gt;(old[wrappedR][wrappedC]);
                }
            }

            <span class="code-keyword">const</span> <span class="code-keyword">bool</span> isAlive = old[r][c];
            res[r][c] = neighboursCount == <span class="code-literal">3</span> || (isAlive && neighboursCount == <span class="code-literal">2</span>);
        }
    }

    <span class="code-keyword">return</span> res;
}</code></pre>
<p>In essence, the entire logic of the game boils down to this single line: <code>res[r][c] = neighboursCount == 3 || (isAlive && neighboursCount == 2);</code>. The rest is just scanning cells and their neighbors.</p>
<p>Notice that I added wrapping to the canvas. This means if a live cell "goes off" the screen on the right, it reappears on the left. This was done to make life on a small canvas less likely to fizzle out into nothingness and more likely to sustain itself for as long as possible.</p>
<p>Sneakily, I also slapped a consteval onto the function, and the compiler didn’t even complain. Just like that—it’s perfectly okay with evaluating this at compile-time! Loops, branching, creating new variables—all of these luxuries are available to us. The toothless constexpr from the distant era of C++11 couldn’t handle loops or local variables, demanded a single return, and allowed branching only via the ternary operator. Remembering all that, I’m honestly amazed at the current compile-time capabilities of the language.</p>
<p>Now, let’s create a variable to store the second generation of cells:</p>
<pre><code class="language-cpp"><span class="code-keyword">constexpr</span> Canvas newLife = <span class="code-call">update</span>(life);</code></pre>
<p>And, of course, we’ll use our little trick with this variable to stop the compiler from stripping everything out:</p>
<pre><code class="language-cpp"><span class="code-keyword">int</span> <span class="code-call">main</span>()
{
    <span class="code-keyword">return</span> newLife[<span class="code-literal">0</span>][<span class="code-literal">0</span>];
}</code></pre>
<p>Theoretically, we now have the second frame of the game calculated at compile-time. The only thing left to figure out is how to actually <i>see</i> it.</p>
<h2>Extracting the Information</h2>
<p>How do we get the result after the compiler finishes its work? The first idea that came to mind was to make the compiler generate an ASM listing alongside the binary and check there. Our calculated second frame should definitely be there as a constant. Alternatively, we could parse the <code>exe</code> file—it should also contain this constant in some form. However, parsing a binary file with a complex structure reeks of madness.</p>
<h3>Assembly</h3>
<p>To get an ASM file, the compiler needs the <code>/Fa</code> flag. To prevent the file from being overly bloated, we’ll also apply the highest level of optimization, while crossing our fingers that the optimizer doesn’t aggressively prune the frame we’re looking for. For optimization, we’ll add the <code>/O2</code> flag. In the end, we run the following command:</p>
<pre><code class="language-bash">cl /std:c++latest /Fa /O2 main.cpp</code></pre>
<p>Now, in addition to <code>main.exe</code>, we get a file named <code>main.asm</code>. Let’s take a look inside. Before we get to the actual assembly opcodes, there’s a section for declaring constant data, where we can see our familiar <code>newLife</code> represented as a set of 256 numbers. Here's a snippet of the listing:</p>
<pre><code class="language-asm">CONST	SEGMENT
?newLife@@<span class="code-literal">3</span>V?$array@V?$array@_N$<span class="code-literal">0</span>BA@@std@@$<span class="code-literal">0</span>BA@@std@@B DB <span class="code-literal">00</span>H ; newLife
	DB	<span class="code-literal">00</span>H
...
	DB	<span class="code-literal">00</span>H
	DB	<span class="code-literal">01</span>H
	DB	<span class="code-literal">00</span>H
	DB	<span class="code-literal">01</span>H
	DB	<span class="code-literal">00</span>H
...
	DB	<span class="code-literal">00</span>H
	DB	<span class="code-literal">01</span>H
	DB	<span class="code-literal">01</span>H
	DB	<span class="code-literal">00</span>H
	DB	<span class="code-literal">00</span>H
...
	DB	<span class="code-literal">00</span>H
	DB	<span class="code-literal">00</span>H
	DB	<span class="code-literal">00</span>H
	DB	<span class="code-literal">00</span>H
	DB	<span class="code-literal">01</span>H
	DB	<span class="code-literal">00</span>H

...</code></pre>
<p>I copied this data array and tweaked it a bit in a text editor to make the frame readable:</p>
<pre><code class="language-"><span class="code-literal">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></code></pre>
<p>Well, does it look like the second frame of a diagonally moving Glider? Seems like it does! I applied the same scheme for the third and fourth frames:</p>
<pre><code class="language-cpp"><span class="code-keyword">constexpr</span> Canvas third = <span class="code-call">update</span>(<span class="code-call">update</span>(life));
<span class="code-comment">// и</span>
<span class="code-keyword">constexpr</span> Canvas fourth = <span class="code-call">update</span>(<span class="code-call">update</span>(<span class="code-call">update</span>(life)));</code></pre>
<p>Got the following "images":</p>
<pre><code class="language-"><span class="code-literal">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></code></pre>
<pre><code class="language-"><span class="code-literal">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></code></pre>
<p>The doubts are gone — this is our Glider, which means the Game of Life frames are being calculated correctly.</p>
<h3>Binary File</h3>
<p>Now let’s try to dig into the binary file and find the same data that we saw in the ASM listing.</p>
<p>To do this, we’ll need at least a superficial understanding of the structure of an <code>.exe</code> file. I didn’t have that knowledge, but fortunately, I knew where to get it easily and painlessly — I remembered that <a href="https://www.youtube.com/@AlekOS">Alek OS</a> had a <a href="https://www.youtube.com/watch?v=-OzGawe9fmM">video</a> on YouTube where he explained the format of Windows binaries. By the way, I highly recommend Alek OS to everyone — his videos have filled more than one gap in my general knowledge that’s useful for any programmer.</p>
<p>Let’s not dive into dense thickets and instead demonstrate how I learned to jump through a binary file to the places needed for my task:</p>
<p>The array of our frame should be located in the <code>.rdata</code> section of the binary file. This is where all the read-only data resides.</p>
<p>The header, explaining where to go to find the <code>.rdata</code> section, is located almost at the beginning of the file:</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/7q/eb/zz/7qebzzjfouzjjggfnjkxvrbzziu.png" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>In the image, we see the beginning of the <code>.exe</code> file in a hex editor. Highlighted in yellow are 8 bytes allocated for the <code>.rdata</code> label. Moving 12 bytes forward from the yellow area, we find information about the starting location of the <code>.rdata</code> section in the file, marked in red. Since this is little-endian, <code>00 F0 00 00</code> translates to the offset <code>0xF000</code>.</p>
<p>Let's head straight there and take a look:</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/tx/44/qx/tx44qxvj7jaxmwzhke1nnr086ry.png" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>Hmm, nothing resembling our array is visible. In desperation, we scroll down a bit:</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/ez/dr/zy/ezdrzyl1ioivefadv_zydjjzm90.png" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>And there it is! Our Glider, recognizable immediately even amidst the binary noise. Viewing the executable's internals with Far3, set to display 16 bytes per line, reveals our 16x16 matrix perfectly readable—even in raw binary!</p>
<p>I couldn't discern what data precedes our array in the <code>.rdata</code> section, nor the rationale behind the array's specific placement. It likely stems from arbitrary compiler decisions.</p>
<p>However, I did discover that regardless of the compilation, the array consistently appears at byte <code>0x320</code> within the <code>.rdata</code> section (or byte <code>0xF320</code> from the file's start). Yes, this "magic number" may vary with compiler quirks or celestial alignments, but as long as the array remains there, I can parse the binary and extract the results of the constexpr program!</p>
<p>Parsing the binary is much more elegant than parsing assembly text, so we'll stick with this approach to retrieve the output.</p>
<hr>
<h2>Bringing the Game to Life</h2>
<p>Now pay close attention—our abnormal programming journey continues here.</p>
<p>We'll copy the contents of our <code>life</code> array into a file named <code>life.txt</code>:</p>
<pre><code class="language-">{_,X,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,X,_,_,_,_,_,_,_,_,_,_,_,_,_},
{X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},
{_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_},</code></pre>
<p>And in our C++ code, we'll implement a truly hacker-worthy inclusion:</p>
<pre><code class="language-cpp"><span class="code-keyword">constexpr</span> Canvas life { {
    #<span class="code-keyword">include</span> <span class="code-literal">"life.txt"</span>
} };</code></pre>
<p>From now on, we consider the <code>life.txt</code> file as our "rendering window." And, as you may have noticed, it simultaneously serves as part of the C++ code.</p>
<p>Our clever plan is as follows:</p>
<ul>
	<li>Compile the program</li>
	<li>Parse the exe file to extract the new Game of Life frame</li>
	<li>Write the new frame back into <code>life.txt</code></li>
	<li>Repeat until we get tired of it</li>
</ul>
<p>We can easily script this solution into an infinite loop using Python.</p>
<p>The brilliance and absurdity of this idea lie in the fact that if you view <code>life.txt</code> in any text editor that supports live content updates while running the script, you’ll effectively observe the Game of Life in motion! And in ASCII graphics, no less. Actually, it might be more accurate to call it C++-syntax graphics, as this content remains valid C++ code throughout. C++ code that mutates with each frame of the game. It's practically <a href="https://en.m.wikipedia.org/wiki/Evolutionary_programming">evolutionary programming</a> in action.</p>
<h2>Writing the Main Loop</h2>
<p>At this point, the article takes a sharp linguistic turn, shifting from C++ to Python.</p>
<p>Some might protest loudly, accusing me of cheating in plain sight—deliberately avoiding runtime in C++ only to run away to Python's runtime. Fair enough, but technically, I'm not executing the compiled exe file, so the challenge's rules remain intact.</p>
<hr>
<p>Now, let's sketch out our game loop:</p>
<pre><code class="language-python"><span class="code-keyword">def</span> <span class="code-call">update</span>():
    <span class="code-call">compile_cpp</span>()
    life = <span class="code-call">parse</span>()
    <span class="code-call">render</span>(life)

<span class="code-keyword">def</span> <span class="code-call">main</span>():
    <span class="code-keyword">while</span> <span class="code-keyword">True</span>:
        <span class="code-call">update</span>()
        time.<span class="code-call">sleep</span>(<span class="code-literal">0.25</span>)

<span class="code-keyword">if</span> __name__ == <span class="code-literal">"__main__"</span>:
    <span class="code-call">main</span>()</code></pre>
<p>It's straightforward here—inside an infinite loop with a slight delay, we keep invoking <code>update()</code>, which embodies the sequence we described earlier: compilation, parsing, and "rendering."</p>
<p>All that's left for us is to implement the <code>compile_cpp</code>, <code>parse</code>, and <code>render</code> methods.</p>
<h3>Compiling C++</h3>
<p>The first thing we need to learn is how to invoke <code>cl.exe</code> from within a Python script. Keep in mind that this isn’t straightforward, as we need to set up the environment first. Therefore, we start by running the batch script and then the compiler:</p>
<pre><code class="language-python"><span class="code-keyword">def</span> <span class="code-call">compile_cpp</span>():
    ENVIRONMENT_SETUP = r<span class="code-literal">'"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"'</span>

    COMPILE = <span class="code-literal">'cl /std:c++latest /O2 main.cpp'</span>

    os.<span class="code-call">system</span>(f<span class="code-literal">'{ENVIRONMENT_SETUP} && {COMPILE}'</span>)</code></pre>
<p>Notice that I had to combine the two commands into one using <code>&&</code> to push them through a single <code>os.system</code> call. The issue here is that each call to <code>os.system</code> launches a new shell, meaning the context and environment do not persist between calls. If I split the code into two separate commands, I would encounter an error along the lines of "I don’t know who this cl.exe is," because whatever environment setup happens in one <code>os.system</code> call is confined to that call.</p>
<h3>Parsing the Binary</h3>
<p>Now, after successfully compiling the program, let's try parsing the exe file to ensure that all the necessary data is indeed being parsed and extracted.</p>
<pre><code class="language-python">N = <span class="code-literal">16</span>

<span class="code-keyword">with</span> <span class="code-call">open</span>(<span class="code-literal">'main.exe'</span>, <span class="code-literal">'rb'</span>) <span class="code-keyword">as</span> f:
    f.<span class="code-call">seek</span>(<span class="code-literal">0</span>xF320)
    <span class="code-keyword">for</span> r <span class="code-keyword">in</span> <span class="code-call">range</span>(N):
        <span class="code-keyword">for</span> c <span class="code-keyword">in</span> <span class="code-call">range</span>(N):
            <span class="code-call">print</span>(int.<span class="code-call">from_bytes</span>(f.<span class="code-call">read</span>(<span class="code-literal">1</span>)), end=<span class="code-literal">' '</span>)
        <span class="code-call">print</span>()</code></pre>
<p>We get:</p>
<pre><code class="language-"><span class="code-literal">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></code></pre>
<p>Everything is fine, the binary parses correctly, and the magic offset still works. This means we can finalize:</p>
<pre><code class="language-python"><span class="code-keyword">def</span> <span class="code-call">parse</span>():
    life = []

    <span class="code-keyword">with</span> <span class="code-call">open</span>(<span class="code-literal">'main.exe'</span>, <span class="code-literal">'rb'</span>) <span class="code-keyword">as</span> f:
        f.<span class="code-call">seek</span>(<span class="code-literal">0</span>xF320)

        <span class="code-keyword">for</span> r <span class="code-keyword">in</span> <span class="code-call">range</span>(N):
            life.<span class="code-call">append</span>([])
            <span class="code-keyword">for</span> c <span class="code-keyword">in</span> <span class="code-call">range</span>(N):
                cell = int.<span class="code-call">from_bytes</span>(f.<span class="code-call">read</span>(<span class="code-literal">1</span>))
                life[r].<span class="code-call">append</span>(cell)

    <span class="code-keyword">return</span> life</code></pre>
<h3>Rendering to <code>life.txt</code></h3>
<p>The key here is not to break C++ syntax; otherwise, we won’t get the next frame due to a compilation error in the C++ code during the next iteration of <code>update()</code>:</p>
<pre><code class="language-python"><span class="code-keyword">def</span> <span class="code-call">render</span>(life):
    <span class="code-keyword">with</span> <span class="code-call">open</span>(<span class="code-literal">'life.txt'</span>, <span class="code-literal">'w'</span>) <span class="code-keyword">as</span> f:
        <span class="code-keyword">for</span> r <span class="code-keyword">in</span> <span class="code-call">range</span>(N):
            f.<span class="code-call">write</span>(<span class="code-literal">'{'</span>)
            <span class="code-keyword">for</span> c <span class="code-keyword">in</span> <span class="code-call">range</span>(N):
                cell = <span class="code-literal">'X'</span> <span class="code-keyword">if</span> life[r][c] == <span class="code-literal">1</span> <span class="code-keyword">else</span> <span class="code-literal">'_'</span>
                f.<span class="code-call">write</span>(f<span class="code-literal">'{cell},'</span>)
            f.<span class="code-call">write</span>(<span class="code-literal">'},\n'</span>)</code></pre>
<p>Admiring the Results</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/sf/89/ty/sf89tydi7a92arnsc2akhkbmgnk.gif" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>Isn’t it a marvel:</p>
<ul>
	<li><code>constexpr</code>-only</li>
	<li>Mutation of source code</li>
	<li>Source code as visual content</li>
	<li>Without running the binary</li>
</ul>
<h2>Fighting for FPS</h2>
<p>You could say we've achieved what we wanted—a Game of Life simulation computed entirely by the C++ compiler. But for complete satisfaction, I want to address a few remaining issues with our solution.</p>
<p>The first glaring problem is the low FPS. It feels like we're running at about 1 frame per second. On the one hand, what did I expect? Each frame requires launching the compiler from scratch, which then has to process its entire standard cycle of parsing, optimization, and code generation.</p>
<p>Remember the <code>time.sleep(0.25)</code> in my <code>main-loop</code>? Yeah, I definitely overdid it, and I've since removed it—the animation shown above is already running without that delay. Yet the FPS is <i>still painfully low</i>.</p>
<p>Let’s recall that our script must invoke the <code>bat</code> file to configure the shell environment for each frame. Based on my empirical estimates, this step alone accounts for at least half of the total execution time. To fix this, we need a way for the script to run the <code>bat</code> file just once at startup and somehow retain the initialized context. Hmm, once again, I find myself like:</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/p1/t-/7c/p1t-7csilx5ekan-m7ryligjg3o.png" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>So, using <code>os.system</code> doesn't let us retain shell environment settings. I’m no Python expert, but the documentation at <a href="https://docs.python.org/">docs.python.org</a> suggests that if <a href="https://docs.python.org/3/library/os.html#os.system"><code>os.system</code></a> isn't powerful enough for your needs, you can use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run"><code>subprocess.run</code></a>.</p>
<p>Giving in to laziness and my weak will, I turned to ChatGPT, which suggested a solution using <code>subprocess.run</code>. It might not be the most elegant code, but it works.</p>
<p>The key idea: use <code>subprocess.run</code> to invoke our batch file along with the <code>set</code> command:</p>
<pre><code class="language-bash"><span class="code-literal">"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"</span> && set</code></pre>
<p>What does the <code>set</code> command do? If called without arguments, it simply outputs a list of all the current shell environment variables to stdout. Something like this:</p>
<pre><code class="language-bash">$ set
HISTFILE=<span class="code-literal">'/root/.ash_history'</span>
HOME=<span class="code-literal">'/root'</span>
HOSTNAME=<span class="code-literal">'localhost'</span>
IFS=<span class="code-literal">' '</span>
LINENO=<span class="code-literal">''</span>
OLDPWD=<span class="code-literal">'/'</span>
OPTIND=<span class="code-literal">'1'</span>
PAGER=<span class="code-literal">'less'</span> PATH=<span class="code-literal">'/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'</span>
PPID=<span class="code-literal">'1'</span>
PS1=<span class="code-literal">'\h:\w\$ '</span>
PS2=<span class="code-literal">'&gt; '</span>
PS4=<span class="code-literal">'+ '</span>
PWD=<span class="code-literal">'/root'</span>
SHLVL=<span class="code-literal">'3'</span>
TERM=<span class="code-literal">'linux'</span>
TZ=<span class="code-literal">'UTC-01:00'</span> _=<span class="code-literal">'--version'</span>
script=<span class="code-literal">'/etc/profile.d/*.sh'</span></code></pre>
<p>What the cunning ChatGPT suggests:</p>
<ul>
	<li>Run the batch file.</li>
	<li>Run <code>set</code>.</li>
	<li><i>Parse</i> the stdout and save the parsed variables into a dictionary.</li>
	<li>Use <code>subprocess.run</code> to call the C++ compiler in the loop, leveraging its advanced optional argument <code>env=</code> to pass our parsed map!</li>
</ul>
<p>I can't decide whether this is brilliant or just plain stupid—like most of what’s happening in this article.</p>
<p>In the end, we write a <code>setup()</code> function to be called at the start of the script:</p>
<pre><code class="language-python">msvc_env = {}

<span class="code-keyword">def</span> <span class="code-call">setup</span>():
    CMD = r<span class="code-literal">'"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat" && set'</span>
    result = subprocess.<span class="code-call">run</span>(CMD, stdout=subprocess.PIPE, shell=<span class="code-keyword">True</span>)

    <span class="code-keyword">for</span> line <span class="code-keyword">in</span> result.stdout.<span class="code-call">decode</span>().<span class="code-call">splitlines</span>():
        <span class="code-keyword">if</span> <span class="code-literal">'='</span> <span class="code-keyword">in</span> line:
            key, value = line.<span class="code-call">split</span>(<span class="code-literal">'='</span>, <span class="code-literal">1</span>)
            msvc_env[key] = value</code></pre>
<p>And in <code>compile_cpp()</code>, we'll replace <code>os.system</code> with <code>subprocess.run</code> and pass in our environment variables:</p>
<pre><code class="language-python"><span class="code-keyword">def</span> <span class="code-call">compile_cpp</span>():
    COMPILE_CMD = <span class="code-literal">'cl /std:c++latest /O2 main.cpp'</span>

    result = subprocess.<span class="code-call">run</span>(
        COMPILE_CMD,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=<span class="code-keyword">True</span>,
        env=msvc_env
    )</code></pre>
<p>Enjoying the result:</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/ow/bo/hf/owbohfdfkthtajt_axbl7j8ixaa.gif" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>By my estimation, it’s about 5 FPS compared to the old result of 1 FPS. This means our efforts weren’t in vain, and the result improved not just twofold but about fivefold.</p>
<p>It’s also worth mentioning that the compiler has a <code>/MP{n}</code> flag, which forces it to work in multiple threads, but my experiments showed that, in my case, the benefit was negligible.</p>
<h2>Compile-time Random</h2>
<p>Technically, we have a working version of Game of Life, but it’s static, with a lone figure on the canvas. What we want is an explosion of cellular chaos, with cells interacting with each other. Manually populating the starting frame is a tedious and thankless task; we’d like to randomize the first frame so that every run has an unpredictable scenario.</p>
<p>These desires bring us two problems to solve. First, how do we implement randomness under <code>constexpr</code> conditions? Second, we need to somehow tell the compiler that the canvas should be randomly populated <b>only during the first compilation.</b> Subsequent runs should work in simulation mode, as in the current implementation.</p>
<p>Let’s set the second problem aside for now and focus on implementing compile-time randomness.</p>
<p>The first thing that came to mind was shaders. Specifically, how simple pseudo-random sequences are sometimes implemented in them. Usually, it’s not some sophisticated randomness with proper distribution, but rather a haphazard spaghetti of mathematical operations. For example, I dug this out of my notes:</p>
<pre><code class="language-hlsl"><span class="code-keyword">float</span> random (vec2 st) {
    <span class="code-keyword">return</span> <span class="code-call">fract</span>(<span class="code-call">sin</span>(<span class="code-call">dot</span>(st.xy,
        <span class="code-call">vec2</span>(<span class="code-literal">12.9898</span>,<span class="code-literal">78.233</span>)))*u_time*<span class="code-literal">1.0</span>
    );
}</code></pre>
<p>Looks dubious? I probably can’t resist and will write out the shader before your eyes, as proof that it works quite well:</p>
<pre><code class="language-hlsl"><span class="code-keyword">void</span> <span class="code-call">main</span>() {
    vec2 st = gl_FragCoord.xy/u_resolution.xy;

    st *= <span class="code-literal">10.0</span>;
    st = <span class="code-call">floor</span>(st);

    vec3 back = <span class="code-call">vec3</span>(<span class="code-literal">0.1</span>, <span class="code-literal">0.9</span>, <span class="code-literal">0.5</span>);
    vec3 front = <span class="code-call">vec3</span>(<span class="code-literal">0.2</span>, <span class="code-literal">0.2</span>, <span class="code-literal">0.2</span>);

    gl_FragColor = <span class="code-call">vec4</span>(<span class="code-call">mix</span>(back, front, <span class="code-call">random</span>(st)), <span class="code-literal">1.0</span>);
}</code></pre>
<p>And now, take a look at the result:</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/dk/oj/h8/dkojh84dpq2f4gppxcl1pdfqhbo.gif" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>Does it matter that the randomness here is very pseudo? Not at all. Moreover, you don’t even need to go to the lengths shown in the shader — a simple but effective pseudo-random number generator can be implemented using a straightforward formula with operations that are perfectly valid in a <code>consteval</code> context:</p>
<p class="latex">$$
R_{n+1}=(R_n*a+b) \bmod m
$$</p>
<p>Or, to put it simply, for the next number in the sequence, we:</p>
<ul>
	<li>Multiply it by something large and preferably prime</li>
	<li>Add something large and preferably prime</li>
	<li>Take the modulus with something large and preferably prime, or even better, something cleverly bit-shifted</li>
</ul>
<p>I settled on:</p>
<pre><code class="language-cpp">seq = (<span class="code-literal">110351545</span> * seq + <span class="code-literal">12345</span>) % (<span class="code-literal">1</span> &lt;&lt; <span class="code-literal">31</span>);</code></pre>
<p>The problem is that the sequence will always be the same unless we find a way to start it with some random seed. Yes, to implement randomness, we need randomness—classic. In the shader example, the seed was the current time.</p>
<p>I went digging around the internet and eventually stumbled upon a GitHub snippet. No need to follow the link; I'll tell you right away what I gleaned from it: the author uses the <code><b>TIME</b></code> macro as a seed. Yes, it's also time, but in a peculiar format.</p>
<p>In fact, this macro is paired with the <code><b>DATE</b></code> macro. Both work quite intriguingly. Let's recall how macros work in principle: before parsing, the compiler runs the preprocessor, which substitutes text where the macros are located. Only after this does actual compilation of the source code begin. For <code><b>DATE</b></code> and <code><b>TIME</b></code>, the preprocessor substitutes string literals of the current build time in the format <code>"Jan 14 2012"</code> and <code>"22:29:12"</code>. It's fascinating to realize that with such macros in your code, the source code reaching the compiler is slightly different every time since <code><b>TIME</b></code> expands to a different string literal every second. My experiments, however, showed that with <code><b>TIME</b></code>, the substitution updates every 10 seconds for some reason—likely due to specifics of the MSVC preprocessor implementation. For our purposes, this limitation poses no problem.</p>
<p>In practice, the string is perfectly embedded in the assembly file. If I write something like this in the C++ code:</p>
<pre><code class="language-cpp"><span class="code-keyword">constexpr const char</span>* dd = __DATE__;
<span class="code-keyword">constexpr</span> <span class="code-keyword">const</span> <span class="code-keyword">char</span>* tt = __TIME__;</code></pre>
<p>then the asm listing will include a snippet like this:</p>
<pre><code class="language-asm">;	COMDAT ??_C@_08BCGBJOAF@<span class="code-literal">20?313?330</span>@
CONST	SEGMENT
??_C@_08BCGBJOAF@<span class="code-literal">20</span>?<span class="code-literal">313</span>?<span class="code-literal">330</span>@ DB <span class="code-literal">'20:13:30'</span>, <span class="code-literal">00</span>H		; `string<span class="code-literal">'
CONST	ENDS
;	COMDAT ??_C@_0M@DINKGNNG@Nov?520?52024@
CONST	SEGMENT
??_C@_0M@DINKGNNG@Nov?520?52024@ DB '</span>Nov <span class="code-literal">20</span> <span class="code-literal">2024'</span>, <span class="code-literal">00</span>H	; `string<span class="code-literal">'
CONST	ENDS</span></code></pre>
<p>That's how I inadvertently revealed the time this article was written.</p>
<p>Alright—how do we use a <code>const char*</code> as a seed? By hashing it into a number, of course. We'll write a custom hash. Here’s a function that returns a <code>consteval</code> seed:</p>
<pre><code class="language-cpp"><span class="code-keyword">consteval</span> uint32_t <span class="code-call">seed</span>()
{
    uint32_t hash = <span class="code-literal">0</span>;

    <span class="code-keyword">for</span> (<span class="code-keyword">int</span> i : {<span class="code-literal">0</span>, <span class="code-literal">1</span>, <span class="code-literal">3</span>, <span class="code-literal">4</span>, <span class="code-literal">6</span>}) {
        hash += <span class="code-keyword">static_cast</span>&lt;uint32_t&gt;(__TIME__[i]);
    }

    <span class="code-keyword">return</span> hash;
}</code></pre>
<p>Why indices 0, 1, 3, 4, 6? If <code><b>TIME</b></code> only changes every 10 seconds, then the truly variable parts of the constant <code>"20:13:30"</code> are only those indices. The last character at index 7 will always remain unchanged, even though it isn’t a <code>:</code>.</p>
<hr>
<p>So, let’s combine this knowledge and create the function <code>consteval Canvas random_canvas()</code>:</p>
<pre><code class="language-cpp"><span class="code-keyword">consteval</span> Canvas <span class="code-call">random_canvas</span>()
{
    Canvas res;

    uint32_t seq = <span class="code-call">seed</span>();

    <span class="code-keyword">for</span> (uint32_t r = <span class="code-literal">0</span>; r &lt; N; ++r) {
        <span class="code-keyword">for</span> (uint32_t c = <span class="code-literal">0</span>; c &lt; N; ++c) {
            seq = (<span class="code-literal">110351545</span>  * seq + <span class="code-literal">12345</span>) % (<span class="code-literal">1</span> &lt;&lt; <span class="code-literal">31</span>);
            res[r][c] = seq % <span class="code-literal">3</span> == <span class="code-literal">0</span>;
        }
    }

    <span class="code-keyword">return</span> res;
}</code></pre>
<p>What is <code>seq % 3 == 0</code>? Well, it’s a sort of threshold, a weird attempt to decide whether a cell is alive or dead. I’m not sure how sound this solution is, but it ended up giving me good results for generating the first frame. For example, here’s one:</p>
<pre><code class="language-">{X,X,_,_,X,X,_,_,X,X,_,_,_,_,_,_,},
{_,X,_,_,_,X,X,X,_,_,_,_,_,X,X,_,},
{_,_,_,_,_,_,X,_,X,_,X,_,_,X,X,_,},
{_,X,_,_,_,_,_,_,_,_,_,_,_,_,X,_,},
{_,_,_,X,_,X,_,_,X,_,_,X,X,_,X,X,},
{_,_,_,_,_,_,_,_,_,X,X,_,_,_,_,_,},
{_,_,X,X,_,X,_,X,_,_,_,_,X,X,_,_,},
{_,X,X,_,_,_,_,_,_,_,_,_,X,_,_,_,},
{X,_,X,_,_,X,_,_,X,_,_,X,_,_,_,_,},
{X,_,_,_,X,_,X,_,_,X,X,X,_,X,X,_,},
{_,_,_,_,X,X,_,X,_,X,_,_,_,_,X,X,},
{_,X,_,_,_,X,X,_,X,X,_,X,X,_,_,_,},
{_,_,_,_,X,_,_,X,X,_,_,_,X,_,X,_,},
{_,_,X,_,_,_,_,X,_,_,X,_,_,_,X,_,},
{_,_,_,_,_,_,_,_,X,X,_,_,X,_,_,_,},
{_,X,_,X,_,_,X,_,X,X,X,_,_,X,_,_,},</code></pre>
<p>I think it’s a worthy first frame.</p>
<h2>Implementing Conditional Compilation</h2>
<p>The final hurdle in our way is figuring out how to make the compiler understand what it’s supposed to do: generate the first random frame or simulate a new frame based on the previous one.</p>
<p>This puzzle kept me busy for a while, as it wasn’t immediately obvious how C++ code could determine whether it was being run <i>for the first time</i> or not. Then I remembered: this is C++, and you can smother it in macros until you lose your mind. Sometimes, these macros can work wonders, as we’ve already seen with <code><b>TIME</b></code>.</p>
<p>The solution turned out to be simple—almost prosaic. Any compiler allows you to pass custom <code>define</code>s at runtime so that the code can behave differently based on them. For MSVC, this is done using the <code>/D{define_name}</code> flag. This approach is as old as time itself, but you tend to forget about it when you need it most because, these days, macros are trendy to bash and shame.</p>
<p>So, the classic approach comes into play. Previously, we had:</p>
<pre><code class="language-cpp"><span class="code-keyword">constexpr</span> Canvas newLife = <span class="code-call">update</span>(life);</code></pre>
<p>Now it becomes:</p>
<pre><code class="language-cpp">#<span class="code-keyword">ifdef</span> STARTUP
<span class="code-keyword">constexpr</span> Canvas newLife = <span class="code-call">random_canvas</span>();
#<span class="code-keyword">else</span>
<span class="code-keyword">constexpr</span> Canvas newLife = <span class="code-call">update</span>(life);
#<span class="code-keyword">endif</span></code></pre>
<p>The changes on the script side concern how the compiler is invoked:</p>
<pre><code class="language-python">first_build = <span class="code-keyword">True</span>

<span class="code-keyword">def</span> <span class="code-call">compile_cpp</span>():
    <span class="code-keyword">global</span> first_build

    STARTUP_CMD = <span class="code-literal">'/DSTARTUP'</span> <span class="code-keyword">if</span> first_build <span class="code-keyword">else</span> <span class="code-literal">''</span>
    COMPILE_CMD = f<span class="code-literal">'cl /std:c++latest /O2 {STARTUP_CMD} main.cpp'</span>

    result = subprocess.<span class="code-call">run</span>(
        COMPILE_CMD,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=<span class="code-keyword">True</span>,
        env=msvc_env
    )

    first_build = <span class="code-keyword">False</span></code></pre>
<p>In the first iteration of the main loop, the script will invoke the compiler like this:</p>
<pre><code class="language-bash">cl /std:c++latest /O2 /DSTARTUP main.cpp</code></pre>
<p>Subsequent runs will omit <code>/DSTARTUP</code>:</p>
<pre><code class="language-bash">cl /std:c++latest /O2 main.cpp</code></pre>
<h2>Final</h2>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/pi/eb/pc/piebpckpqs8juxfsyfiffrcs1to.gif" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>The frames are jittery due to rough screen recording, but I couldn’t resist including the scenario with the massive spaceship at the end.</p>
<p>As a bonus, here’s how I peer straight into the soul of the exe file as it’s relentlessly altered by the compiler. I observe, but I do not run it!</p>

<div class="image">
    <figure>
        <img src="https://habrastorage.org/webt/ub/2b/2x/ub2b2xmwbd0y4khzh9agr8uzahe.gif" alt="">
        <figcaption></figcaption>
    </figure>
</div>

<p>Far3 doesn’t deliver such good FPS, but just the ability to see these "guts" is satisfying in itself. The <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.hexeditor">Hex Editor</a> extension for VS Code displays changes in the binary file faster, almost in real-time, but it lacks those fun emojis for the byte <code>01</code>.</p>
<h2>What Was That?</h2>
<p>I’m asking myself the same question. However, let’s retrospectively look at what we’ve done and what we’ve mastered:</p>
<ul>
	<li>Learned some nuances of <code>constexpr</code></li>
	<li>Figured out how to use MSVC without an IDE</li>
	<li>Dug into the guts of an exe file bare-handed and even found what we were looking for</li>
	<li>Played around with macros, hehe</li>
	<li>Started with C++ and ended with Python</li>
	<li>Explored the intricacies of <code>os.system</code> and <code>subprocess.run</code></li>
	<li>For some reason, I showed you a shader</li>
	<li>Achieved compile-time randomness</li>
	<li>Wrote a "game"</li>
	<li>Didn’t run the binary but just stood nearby!</li>
	<li>And had fun in the process</li>
</ul>
<p>Abnormal programming makes life more enjoyable. Just don’t bring this to production.</p>
<hr>
<small>© Nikolai Shalakin. Originally published by <a href="https://habr.com/ru/articles/860150/">habr.com</a>, used under CC BY 3.0. Translated by the author.</small>
<script type="text/javascript" src="../theme-script.js"></script>
<script type="text/javascript" src="../typography-change-script.js"></script>
</body>
</html>